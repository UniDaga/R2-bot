import json, time
from web3 import Web3
from decimal import Decimal
from eth_abi import encode
from rich.console import Console
from rich.panel import Panel
from time import sleep
from rich.live import Live
from rich.text import Text
import random 
console = Console()

console.print("-" * 50)

RPC = "https://testnet.dplabs-internal.com"
CHAIN_ID = 688688
web3 = Web3(Web3.HTTPProvider(RPC))
chain_id = web3.eth.chain_id
ROUTER_MATRIX = Web3.to_checksum_address("0x47d1B0623bB3E557bF8544C159c9ae51D091F8a2")
ROUTER = Web3.to_checksum_address("0x4f5b54d4af2568cefafa73bb062e5d734b55aa05")
R2USD = web3.to_checksum_address("0x4f5b54d4af2568cefafa73bb062e5d734b55aa05")
sR2USD = web3.to_checksum_address("0xf8694d25947a0097cb2cea2fc07b071bdf72e1f8")

STAKING_CONTRACT = web3.to_checksum_address("0xf8694d25947a0097cb2cea2fc07b071bdf72e1f8")

TOKENS = {
    "USDC": Web3.to_checksum_address("0x8bebfcbe5468f146533c182df3dfbf5ff9be00e2"),
    "R2USD": Web3.to_checksum_address("0x4f5b54d4af2568cefafa73bb062e5d734b55aa05"),
    "sR2USD": Web3.to_checksum_address("0xf8694d25947a0097cb2cea2fc07b071bdf72e1f8")
}

# Global nonce tracker for each wallet
nonce_tracker = {}

ERC20_ABI = [
    {
        "constant": True,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": True,
        "inputs": [{"name": "_owner", "type": "address"}, {"name": "_spender", "type": "address"}],
        "name": "allowance",
        "outputs": [{"name": "", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": False,
        "inputs": [{"name": "_spender", "type": "address"}, {"name": "_value", "type": "uint256"}],
        "name": "approve",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    }
]

try:
    with open("token_abi.json") as f:
        erc20_abi = json.load(f)
    with open("router_swap_abi.json") as f:
        router_swap_abi = json.load(f)
except Exception as e:
    console.print(f"[red]❌ Failed to load ABI JSON file: {str(e)}[/red]")
    exit()

try:
    with open("network_config.json") as f:
        config = json.load(f)
except Exception as e:
    console.print(f"[red]❌ Failed to load config: {str(e)}[/red]")
    exit()

web3 = Web3(Web3.HTTPProvider(config["rpc"]))
if not web3.is_connected():
    console.print("[red]❌ Failed to connect to RPC[/red]")
    exit()
console.print("[green]✅ Connected to RPC[/green]")

CHAIN_ID = config["chain_id"]
TOKEN_MAPPING = {k: Web3.to_checksum_address(v["address"]) for k, v in config["tokens"].items()}

def get_managed_nonce(addr):
    """Get nonce for address, managing it locally to avoid conflicts"""
    global nonce_tracker
    
    if addr not in nonce_tracker:
        # First time for this wallet - get fresh nonce from network
        nonce_tracker[addr] = web3.eth.get_transaction_count(addr, "pending")
        console.print(f"[dim]🔢 Initial nonce for {short(addr)}: {nonce_tracker[addr]}[/dim]")
    else:
        # Increment local nonce for subsequent transactions
        nonce_tracker[addr] += 1
        console.print(f"[dim]🔢 Using nonce for {short(addr)}: {nonce_tracker[addr]}[/dim]")
    
    return nonce_tracker[addr]

def reset_nonce_tracker():
    """Reset nonce tracker - call this at start of each main loop"""
    global nonce_tracker
    nonce_tracker = {}

def get_gas_price(): return int(web3.eth.gas_price * Decimal(2))
def get_gas(): return web3.eth.gas_price + Web3.to_wei(5, 'gwei')
def short(addr): return f"{addr[:6]}...{addr[-4:]}"
def get_erc20(address): return web3.eth.contract(address=address, abi=erc20_abi)

def tx_delay():
    time.sleep(2)  # Reduced delay since we're not waiting for confirmation

def swap_token(amount, path, sender, privkey, router_addr, label):
    try:
        with open("router_swap_abi.json") as f: abi = json.load(f)
        contract = web3.eth.contract(address=router_addr, abi=abi)
        tx = contract.functions.swapExactTokensForTokens(
            amount, 
            0, 
            [Web3.to_checksum_address(p) for p in path], 
            sender, 
            int(time.time()) + 600
        ).build_transaction({
            "chainId": CHAIN_ID, 
            "from": sender, 
            "gasPrice": get_gas(),
            "nonce": get_managed_nonce(sender),  # Use managed nonce
            "gas": 600000
        })
        signed = web3.eth.account.sign_transaction(tx, privkey)
        tx_hash = web3.eth.send_raw_transaction(signed.raw_transaction)
        
        show_status(f"Swap {label}", sender, router_addr, "[yellow]Submitted[/yellow]", web3.to_hex(tx_hash))
        tx_delay()
        return True
        
    except Exception as e:
        show_status(f"Swap {label}", sender, router_addr, f"[red]Error: {str(e)}[/red]")
        return False

def show_status(action, sender, contract, status, tx_hash=None): 

    if tx_hash:
        console.print(f"🔗 TX Hash    https://pharos-testnet.socialscan.io//tx/{tx_hash}")
    console.print("─" * 50)

def approve_token_swap(sender, spender, amount, privkey, token_addr, label):
    try:
        contract = get_erc20(token_addr)
        allowance = contract.functions.allowance(sender, spender).call()
        if allowance >= amount:
            show_status(f"Approve {label}", sender, token_addr, "[green]Already Approved[/green]")
            return True

        tx = contract.functions.approve(spender, amount).build_transaction({
            "from": sender,
            "nonce": get_managed_nonce(sender),  # Use managed nonce
            "gasPrice": get_gas(),
            "chainId": CHAIN_ID,
            "gas": 600000
        })
        signed = web3.eth.account.sign_transaction(tx, privkey)
        tx_hash = web3.eth.send_raw_transaction(signed.raw_transaction)
        
        show_status(f"Approve {label}", sender, token_addr, "[yellow]Submitted[/yellow]", web3.to_hex(tx_hash))
        tx_delay()
        return True

    except Exception as e:
        show_status(f"Approve {label}", sender, token_addr, f"[red]{str(e)}[/red]")
        return False
        
def approve_token_stake(token_addr, owner, spender, amount, key):
    contract = web3.eth.contract(address=token_addr, abi=ERC20_ABI)
    tx = contract.functions.approve(spender, amount).build_transaction({
        'chainId': chain_id,
        'from': owner,
        'nonce': get_managed_nonce(owner),  # Use managed nonce
        'gas': 600000,
        'gasPrice': get_gas_price()
    })
    signed = web3.eth.account.sign_transaction(tx, key)
    tx_hash = web3.eth.send_raw_transaction(signed.raw_transaction)
    
    tx_delay()

def stake_r2usd_to_sr2usd(sender, privkey):
    random_amount = round(random.uniform(0.1, 2.0), 6)
    amount = int(Decimal(str(random_amount)) * 10**6)

    token = web3.eth.contract(address=R2USD, abi=ERC20_ABI)

    balance = token.functions.balanceOf(sender).call()
    if balance < amount:
        console.print(f"[yellow]⚠️ R2USD too low ({balance / 1e6})[/yellow]")
        return

    allowance = token.functions.allowance(sender, sR2USD).call()
    if allowance < amount:
        approve_token_stake(R2USD, sender, sR2USD, amount, privkey)

    try:
        data = bytes.fromhex("1a5f0f00") + encode(["uint256"] * 10, [amount] + [0]*9)
        tx = {
            'chainId': chain_id,
            'from': sender,
            'to': sR2USD,
            'nonce': get_managed_nonce(sender),  # Use managed nonce
            'gasPrice': get_gas_price(),
            'gas': web3.eth.estimate_gas({'from': sender, 'to': sR2USD, 'data': data}),
            'data': data
        }
        signed = web3.eth.account.sign_transaction(tx, privkey)
        tx_hash = web3.eth.send_raw_transaction(signed.raw_transaction)
        
        console.print("[yellow]📤 Staking transaction submitted[/yellow]")
        tx_delay()
        return tx_hash
    
    except Exception as e:
        show_status("Stake R2USD → sR2USD", sender, sR2USD, f"[red]{str(e)}[/red]")

def main():
    # Reset nonce tracker at the start of each cycle
    reset_nonce_tracker()
    
    try:
        with open("accounts.txt") as f:
            wallets = [x.strip() for x in f if x.strip()]
    except FileNotFoundError:
        console.print("[red]❌ File accounts.txt not found![/red]")
        return

    for i, pk in enumerate(wallets, 1):
        try:
            acc = web3.eth.account.from_key(pk)
            sender = acc.address
            console.print(f"\n[bold cyan]▶ Wallet {i}: {short(sender)}[/bold cyan]")
            console.print("─" * 50)

            token_usdc = TOKEN_MAPPING["USDC"]
            token_r2usd = TOKEN_MAPPING["R2USD"]
            
            random_amount = round(random.uniform(0.1, 2.0), 6)
            amount_usdc = int(Decimal(str(random_amount)) * 10**config["tokens"]["USDC"]["decimals"])
            approve_token_swap(sender, token_r2usd, amount_usdc, pk, token_usdc, "USDC")

            func_selector = bytes.fromhex("095e7a95")
            encoded_args = encode(
                ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256', 'uint256'],
                [sender, amount_usdc, 0, 0, 0, 0, 0]
            )
            data = func_selector + encoded_args
            tx = {
                'chainId': CHAIN_ID,
                'from': sender,
                'to': token_r2usd,
                'data': web3.to_hex(data),
                'gasPrice': get_gas(),
                'nonce': get_managed_nonce(sender),  # Use managed nonce
                'gas': 600000
            }
            signed_tx = web3.eth.account.sign_transaction(tx, pk)
            tx_hash = web3.eth.send_raw_transaction(signed_tx.raw_transaction)
            
            status = "[yellow]Submitted[/yellow]"
            show_status("Buy USDC → R2USD", sender, token_r2usd, status, web3.to_hex(tx_hash))
            tx_delay()

            approve_token_stake(TOKENS["R2USD"], sender, STAKING_CONTRACT, 999999999, pk)
            tx_hash = stake_r2usd_to_sr2usd(sender, pk)
            if tx_hash:
                show_status("Stake R2USD", sender, STAKING_CONTRACT, "[yellow]Submitted[/yellow]", web3.to_hex(tx_hash))

        except Exception as e:
            console.print(f"[red]❌ Wallet {i} Error: {str(e)}[/red]")
            console.print("─" * 50)

if __name__ == "__main__":
    while True:
        try:
            console.print("\n[bold yellow]⏳ R2 Testnet Full Auto  [/bold yellow]")
            main()
            console.print("[bold green]✅ All processes completed. Waiting 24 hours before restarting...[/bold green]")
            console.print("🕒 Next time: " + time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time() + 86400)))
            time.sleep(86400)
        except Exception as e:
            console.print(f"[red]❌ Error occurred during loop: {e}[/red]")
            console.print("[yellow]⏳ Retrying after 60 seconds...[/yellow]")
            time.sleep(60)
